\chapter{Requirements for a Future Scheduler Architecture}%
\label{chap:requirements}

After discussing the problem domain covered by this dissertation in the previous chapters, this chapter substantiates the requirements that a novel scheduler architecture has to consider. Not every requirement can be tracked down to a single problem or issue, most of them will rather relate to several ones at the same time. The following sections are naming the requirements that have to be considered with a new approach to scheduler architecture.

\section{Flexible Task Model}

A future scheduler architecture has to be as general as possible regarding the task model. This requirement stems from two facts: First, the tendency that single operating systems are used across several application domains and, second, the differing execution models of \acp{PE} and processing accelerators. A flexible task model is a key to enabling the operating system to manage arbitrary \acp{PE} and accelerators.

Regarding the application domain and the utilized scheduling policies, different properties of a task are relevant. For example, a \ac{FCFS} algorithm would require the arrival time of a task, while a \ac{SRT} based algorithm needs information about the remaining runtime. This means that a suitable scheduler architecture should not limit the developer regarding the management of such properties. Therefore, an approach is needed that allows a dynamic definition and introduction of relevant properties.

The execution model has to be general in a way that it does not matter how and where a task is running. The runtime system will decide how it uses the scheduling decision and puts it into action. The scheduler only has to decide which task will be most suited to the current situation when queried by the runtime system. That especially rules out one assumption made by operating system schedulers today, namely that the scheduling for each independent \ac{PE} happens on that \ac{PE} itself. Processing accelerators often cannot compute a schedule on their own and therefore a decision has to be made for them, \eg, by a general purpose \ac{PE}. Furthermore, a rising number of cores might enable the possibility of dedicated scheduling cores or even dedicated schedulers in hardware based on \ac{FPGA} technology.

\section{Scalability and Contention}%
\label{sec:requirements:scale}

Scalability is, in general, a desired property for most kinds of software; however, for the process scheduler, it is an indispensable property. The processing time spent in the scheduler is lost for the actual computational tasks assigned to the system. A scheduler that does not scale would increase the amount of processing time lost and might even slow down the whole system. Two aspects are relevant toward the scalability of the scheduler. The first aspect is determined by the complexity of the scheduler implementation and the second one by possible contentions in the implementation.

For the scope of this dissertation, the scalability of the architecture and the scalability of the underlying scheduling algorithm has to be separated. The complexity of a specific scheduling algorithm can de facto not be improved by the given architecture itself. However, on the other side, the architecture should also not worsen the complexity by enforcing its structure. Yet, the most determining factor besides the computational complexity, especially in a many-core system, regarding scalability is contention. The main cause for contentions in the process scheduler are shared data structures that are accessed and modified by several or all \acp{PE} of the system. This could be, for example, a shared runqueue. To be able to create a scalable scheduler for many-core systems, it is necessary for a future scheduler architecture to make it possible to implement scheduling policies that minimize the degree of contention.

\section{Adaptability}%
\label{sec:requirements:adaptability}

Future performance improvements might only happen through specialization; therefore, it can be expected that the scheduler has to be specialized to certain workloads especially with a very heterogeneous system. Hence, a scheduler architecture should support changes to the scheduling policy during runtime. As both hardware configuration and workload scenarios become more unpredictable, it will not be sufficient to have a limited selection of scheduling algorithms that can be chosen from at runtime, but it must be possible to add new policies during runtime as well. Taking reconfigurable computing with \ac{FPGA} technology into account, this property becomes indispensable. Hardware reconfiguration becomes only meaningful when the operating system can adapt to the new system as well.

A second aspect that makes adaptability indispensable for future systems is availability. An adaptable system can also increase the availability of a system. This feature is helpful in two scenarios. On the one hand when the need for a bug fix occurs and on the other hand in large scale computers with multiple tenants. With an adaptable system, a faulty scheduler implementation could be replaced during runtime, thus removing the requirement to reboot the system and increasing its availability. While in the latter scenario as, \eg, in \ac{HPC}, the scheduler could be adapted for every customer without a time consuming reboot and reconfiguration of the whole infrastructure.

\section{Runtime System Independence}%
\label{sec:requirements:independence}

The requirement of runtime system independence is mainly based on the insights of \cref{sec:intro:monopol}. From the perspective of a single operating system, the independence of the scheduler implementation seems unnecessary. However, looking at the bigger picture, having a runtime system independent scheduler would make it much easier for specific system software projects with a smaller community and smaller workforce to profit from innovations of bigger projects with a bigger workforce. Also, the creation of new projects would be easier as an existing, well-tested scheduler implementation could serve as a solid foundation. This could increase the pace of the overall innovation process, which would be beneficial to all new, small, and big software projects. Moreover, it would be helpful to keep up with changes in hardware architecture as developers and researchers might concentrate on vital tasks instead of low-level problems.

Another argument for runtime system independence stems from the research point of view. With an independent scheduler architecture, it is easier to identify the properties of a scheduler policy and separate it from the effects of a specific runtime system. It would be possible to evaluate the same implementation in several runtime systems and, through statistics, obliterate the biases introduced by the specific runtime system.

\section{Reusability}

As future systems become more complex, future scheduling policies might become much more sophisticated as well. Particularly in heterogeneous systems, different \acp{PE} might require different scheduling strategies. Therefore, it will be infeasible to have a single homogeneous scheduling strategy for the whole system. To simplify the development of such scheduling policies, the reuse of existing scheduling implementations is desirable. This would dramatically increase the pace of innovation as existing implementations could be combined to form a holistic scheduler for the whole system. Also, reusability reduces development costs and testing efforts as existing, known to work implementations can be used.

In the ideal case, a new scheduler for a very heterogeneous system could be constructed with little implementation effort. It should be possible to take existing implementations for scheduling strategies peculiar to the used \acp{PE} and to combine them to an entirely new scheduler. That way, it is possible to create a scheduler that is suited and perfectly tailored to the specific system.

\section{Information Distribution}

As the heterogeneity in a system rises, so does the need for information to achieve the scheduling goals. The same applies to an increased degree of virtualization that potentially requires the exchange of information between the virtual machines' requirements and the host systems' scheduler. Therefore, a flexible infrastructure is needed in a future scheduler architecture that supports the propagation of information. This is valid for all three kinds of communication: inside the scheduler subsystem, from the runtime system to the scheduler, and from the scheduler to the runtime system.

An information distribution infrastructure might also tackle the issue of cross-cutting concerns. Cross-cutting concerns influence, by definition, several or all parts of a system. To avoid a tight integration and keep the independence of specific subsystems, a communication infrastructure is needed. Even though the overhead introduced by the communication and coordination might be significant, the separation of concerns might still be more desirable to secure maintainability and testability as will be shown in the next sections.
